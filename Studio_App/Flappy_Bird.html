<!--
APP_NAME: Flappy Bird
APP_ICON: https://win98icons.alexmeub.com/icons/png/mplayer-1.png
APP_CATEGORY: Games
WINDOW_WIDTH: 400
WINDOW_HEIGHT: 600
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird</title>
    <style>
        :root {
            --primary-color: #0078d4;
            --secondary-bg-color: #f3f3f3;
            --border-color: #e0e0e0;
            --input-border-color: #d1d1d1;
            --text-color: #333333;
            --light-text-color: #666666;
            --background-color: #ffffff;
            --shadow-color: rgba(0,0,0,0.05);
        }

        /* Ensure html and body take full height of the iframe viewport */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--background-color);
            color: var(--text-color);
            overflow: hidden; /* Prevent body scroll */
            user-select: none; /* Prevent text selection in game */
        }

        .app-container {
            width: 100%;
            height: 100%;
            max-width: 400px;
            max-height: 600px;
            background-color: var(--background-color);
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--shadow-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-area {
            position: relative;
            width: 100%;
            background-color: #70c5ce; /* Sky blue */
            overflow: hidden;
            flex-grow: 1;
        }

        .bird {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #ffd700; /* Gold */
            border-radius: 50%;
            left: 50px;
            top: 250px; /* Initial position, will be set by JS */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            border: 1px solid #ccaa00;
            z-index: 10;
        }

        .pipe {
            position: absolute;
            width: 50px;
            background-color: #74a821; /* Green */
            border: 2px solid #557c17;
            border-radius: 4px; /* Rounded corners for pipes */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        .pipe-top {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .pipe-bottom {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 40px;
            background-color: #d2b48c; /* Sandy brown */
            border-top: 2px solid #5a4b41;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10; /* Ensure ground is on top of pipes */
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.85); /* Slightly less transparent */
            backdrop-filter: blur(2px); /* Subtle blur effect */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none; /* Allow clicks to pass through by default */
        }

        .game-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto; /* Enable clicks when active */
        }

        .game-overlay h2 {
            font-size: 2.2em;
            margin-bottom: 8px;
            color: var(--primary-color);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .game-overlay p {
            font-size: 1.1em;
            margin-bottom: 25px;
            color: var(--text-color);
        }

        .score-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 15;
            pointer-events: none; /* Do not interfere with clicks */
        }

        .button {
            padding: 10px 20px;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            background-color: var(--primary-color);
            color: #ffffff;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 1px 3px var(--shadow-color);
            outline: none;
        }

        .button:hover {
            background-color: #0063af;
            border-color: #0063af;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .button:active {
            background-color: #004a8b;
            border-color: #004a8b;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }

        /* Responsive adjustments for smaller windows */
        @media (max-width: 400px) {
            .app-container {
                border-radius: 0; /* No rounded corners if it fills the iframe */
                box-shadow: none;
            }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <div class="game-area" id="gameArea">
            <div class="bird" id="bird"></div>
            <div class="score-display" id="scoreDisplay">0</div>
            <div class="ground" id="ground"></div>

            <div class="game-overlay" id="startOverlay">
                <h2>Flappy Bird</h2>
                <p>Press space or click to flap!</p>
                <button class="button" onclick="startGame()">Start Game</button>
            </div>

            <div class="game-overlay" id="gameOverOverlay">
                <h2>Game Over!</h2>
                <p>Your score: <span id="finalScore">0</span></p>
                <button class="button" onclick="resetGame()">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        const gameArea = document.getElementById('gameArea');
        const bird = document.getElementById('bird');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startOverlay = document.getElementById('startOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreSpan = document.getElementById('finalScore');
        const ground = document.getElementById('ground');

        let birdY = 0;
        let birdVelocity = 0;
        // Physics adjustments for a snappier feel
        const gravity = 0.8; // Increased gravity for faster fall
        const jumpStrength = -12; // Increased jump strength for more powerful flap

        let pipes = [];
        const pipeWidth = 50;
        const pipeGapHeight = 150;
        // Game pace adjustments for quicker reaction time requirement
        const pipeSpeed = 3; // Increased pipe speed
        const pipeSpawnInterval = 1500; // Decreased interval for more frequent pipes
        let pipeTimer;

        let score = 0;
        let gameStarted = false;
        let isGameOver = false;
        let animationFrameId;

        let gameAreaWidth;
        let gameAreaHeight;
        let playableHeight;
        let birdWidth;
        let birdHeight;
        let groundHeight;

        function updateDimensions() {
            gameAreaWidth = gameArea.clientWidth;
            gameAreaHeight = gameArea.clientHeight;
            birdWidth = bird.clientWidth;
            birdHeight = bird.clientHeight;
            groundHeight = ground.clientHeight;
            playableHeight = gameAreaHeight - groundHeight;
        }

        function updateBirdPosition() {
            if (!gameStarted || isGameOver) return;

            birdVelocity += gravity;
            birdY += birdVelocity;

            if (birdY < 0) {
                birdY = 0;
                birdVelocity = 0;
            }

            if (birdY + birdHeight >= playableHeight) {
                birdY = playableHeight - birdHeight;
                birdVelocity = 0;
                endGame();
                return;
            }

            bird.style.top = `${birdY}px`;
        }

        function flap() {
            if (isGameOver) return;

            if (!gameStarted) {
                // If game hasn't started, the first flap should start the game AND apply the jump
                startGame();
            }
            // Apply the jump strength
            birdVelocity = jumpStrength;
        }

        function createPipe() {
            if (!gameStarted || isGameOver) return;

            const minPipeHeight = 50;
            const maxTopPipeHeight = playableHeight - pipeGapHeight - minPipeHeight;

            // Ensure maxTopPipeHeight is not less than minPipeHeight to avoid invalid range
            let actualMaxTopPipeHeight = Math.max(minPipeHeight, maxTopPipeHeight);
            if (playableHeight - pipeGapHeight < 2 * minPipeHeight) {
                // If the total playable height minus gap is too small for two min pipes,
                // we might have issues. This game might not look good in very small windows.
                // For now, clamp to avoid negative range or ensure min height.
                if (playableHeight < pipeGapHeight + 2 * minPipeHeight) { // Cannot create valid pipes
                    console.warn("Playable area too small for proper pipes.");
                    return;
                }
                actualMaxTopPipeHeight = playableHeight - pipeGapHeight - minPipeHeight;
            }
            
            let topPipeHeight = Math.floor(Math.random() * (actualMaxTopPipeHeight - minPipeHeight + 1)) + minPipeHeight;
            // Ensure bottom pipe is also minimum height
            let bottomPipeHeight = playableHeight - topPipeHeight - pipeGapHeight;
            if (bottomPipeHeight < minPipeHeight) {
                // This scenario means topPipeHeight was too large, or playableHeight is too small
                // Recalculate based on a guaranteed minimum for both and the gap
                topPipeHeight = playableHeight - pipeGapHeight - minPipeHeight; // Max possible top pipe
                if (topPipeHeight < minPipeHeight) topPipeHeight = minPipeHeight; // Ensure min
                bottomPipeHeight = playableHeight - topPipeHeight - pipeGapHeight; // Recalculate bottom
            }
            
            const pipeX = gameAreaWidth;

            const pipeTop = document.createElement('div');
            pipeTop.classList.add('pipe', 'pipe-top');
            pipeTop.style.width = `${pipeWidth}px`;
            pipeTop.style.height = `${topPipeHeight}px`;
            pipeTop.style.left = `${pipeX}px`;
            pipeTop.style.top = `0px`;
            gameArea.appendChild(pipeTop);

            const pipeBottom = document.createElement('div');
            pipeBottom.classList.add('pipe', 'pipe-bottom');
            pipeBottom.style.width = `${pipeWidth}px`;
            pipeBottom.style.height = `${bottomPipeHeight}px`;
            pipeBottom.style.left = `${pipeX}px`;
            pipeBottom.style.top = `${topPipeHeight + pipeGapHeight}px`;
            gameArea.appendChild(pipeBottom);

            pipes.push({
                x: pipeX,
                topHeight: topPipeHeight,
                bottomHeight: bottomPipeHeight,
                pipeTopElement: pipeTop,
                pipeBottomElement: pipeBottom,
                passed: false
            });
        }

        function updatePipes() {
            if (!gameStarted || isGameOver) return;

            pipes.forEach(pipe => {
                pipe.x -= pipeSpeed;
                pipe.pipeTopElement.style.left = `${pipe.x}px`;
                pipe.pipeBottomElement.style.left = `${pipe.x}px`;

                if (pipe.x + pipeWidth < bird.offsetLeft && !pipe.passed) {
                    score++;
                    scoreDisplay.textContent = score;
                    pipe.passed = true;
                }
            });

            if (pipes.length > 0 && pipes[0].x + pipeWidth < 0) {
                gameArea.removeChild(pipes[0].pipeTopElement);
                gameArea.removeChild(pipes[0].pipeBottomElement);
                pipes.shift();
            }
        }

        function checkCollisions() {
            for (let i = 0; i < pipes.length; i++) {
                const p = pipes[i];

                const birdRight = bird.offsetLeft + birdWidth;
                const birdLeft = bird.offsetLeft;
                const birdTop = birdY;
                const birdBottom = birdY + birdHeight;

                const pipeRight = p.x + pipeWidth;
                const pipeLeft = p.x;
                const pipeTopBottom = p.topHeight;
                const pipeBottomTop = p.topHeight + pipeGapHeight;

                if (birdRight > pipeLeft && birdLeft < pipeRight) {
                    if (birdTop < pipeTopBottom || birdBottom > pipeBottomTop) {
                        endGame();
                        return;
                    }
                }
            }
        }

        function gameLoop() {
            if (isGameOver) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            updateBirdPosition();
            updatePipes();
            checkCollisions();
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (gameStarted) return;
            
            updateDimensions();
            resetGame(false);
            
            startOverlay.classList.remove('active');
            gameOverOverlay.classList.remove('active');

            gameStarted = true;
            isGameOver = false;
            score = 0;
            scoreDisplay.textContent = score;
            
            birdY = playableHeight / 2 - birdHeight / 2;
            birdVelocity = 0;
            bird.style.top = `${birdY}px`;

            pipes.forEach(p => {
                if (p.pipeTopElement.parentNode === gameArea) {
                    gameArea.removeChild(p.pipeTopElement);
                }
                if (p.pipeBottomElement.parentNode === gameArea) {
                    gameArea.removeChild(p.pipeBottomElement);
                }
            });
            pipes = [];

            pipeTimer = setInterval(createPipe, pipeSpawnInterval);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            isGameOver = true;
            gameStarted = false;
            clearInterval(pipeTimer);
            cancelAnimationFrame(animationFrameId);

            finalScoreSpan.textContent = score;
            gameOverOverlay.classList.add('active');
        }

        function resetGame(showStartScreen = true) {
            isGameOver = true;
            gameStarted = false;
            clearInterval(pipeTimer);
            cancelAnimationFrame(animationFrameId);

            updateDimensions();

            if (playableHeight > 0) {
                 birdY = playableHeight / 2 - birdHeight / 2;
            } else {
                 birdY = gameAreaHeight / 2 - birdHeight / 2;
            }
            birdVelocity = 0;
            bird.style.top = `${birdY}px`;
            
            score = 0;
            scoreDisplay.textContent = score;

            pipes.forEach(p => {
                if (p.pipeTopElement.parentNode === gameArea) {
                    gameArea.removeChild(p.pipeTopElement);
                }
                if (p.pipeBottomElement.parentNode === gameArea) {
                    gameArea.removeChild(p.pipeBottomElement);
                }
            });
            pipes = [];

            gameOverOverlay.classList.remove('active');
            if (showStartScreen) {
                startOverlay.classList.add('active');
            } else {
                startOverlay.classList.remove('active');
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                flap();
            }
        });

        gameArea.addEventListener('click', (e) => {
            if (!e.target.closest('.game-overlay.active button')) {
                flap();
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            updateDimensions();
            resetGame(true);
        });

        window.addEventListener('resize', updateDimensions);

    </script>
</body>
</html>